import Sidebar from '../components/Sidebar'
import Topbar from '../components/Topbar'
import Footer from "../components/Footer"
import SVGFrameViewer from "../components/SVGFrame"

function FlightPath() {
    const dijkstras = [
       "/flightpath/dijkstra1.svg",
       "/flightpath/dijkstra2.svg",
       "/flightpath/dijkstra3.svg",
       "/flightpath/dijkstra4.svg",
       "/flightpath/dijkstra5.svg",
       "/flightpath/dijkstra6.svg",
       "/flightpath/dijkstra7.svg",
       "/flightpath/dijkstra8.svg",
    ];

    const reconstruct = [
        "/flightpath/reconstruct1.svg",
        "/flightpath/reconstruct2.svg",
        "/flightpath/reconstruct3.svg",
        "/flightpath/reconstruct4.svg",
        "/flightpath/reconstruct5.svg",
        "/flightpath/reconstruct6.svg",
        "/flightpath/reconstruct7.svg",
        "/flightpath/reconstruct8.svg",
     ];


    return (
  <div className="w-full"> 
    <div className="mx-auto max-w-10xl xl:pl-40 lg:pl-10 md:pl-10 md:p-30">
      <Topbar />
      <div className="flex flex-col lg:flex-row gap-10">
        <div className="lg:w-1/4 lg:max-w-[300px] flex-shrink-0">
          <div className="sticky top-10">
            <Sidebar />
          </div>
        </div>
      <div className="space-y-6 pl-5 pr-5">
        <div className="space-y-2">
          <h2 className="text-3xl font-bold text-gray-900">FlightPath Downsview</h2>
          <p className="text-gray-600">Flightpath Downsview is a TypeScript React tool designed to help people who are hearing impaired learn more about Downsview Park during Cycling Without Age rides (the “Navigator” feature). It also includes a “Pathfinder” tool to guide users along the shortest routes between park attractions.</p>
          <h3 className="pt-2">
            <a href="https://flightpath.ourgreenway.ca/" className="bg-gray-300 hover:bg-gray-400 text-lg font-medium px-6 py-2 rounded transition">
            <strong className="text-black">Go to the website</strong>
            </a>
            </h3>
          <h3 className="pt-3 text-2xl font-bold text-gray-900">Pathfinder</h3>
            <p>Pathfinder is a shortest-path feature powered by Dijkstra’s algorithm based on a weighted bi-directional graph, helping users find the quickest route between attractions within Downsview Park.</p>
            
            <div className="pt-3 pb-3">
                <img src="/flightpath/filesystem.svg" alt="Relationship between each node and edge." className="pb-2 w-[10rem] max-w-xl h-auto max-h-96 object-cover sm:max-w-full sm:max-h-none" />
                <i><strong>Image:</strong> relationship between each node and edge.</i>
            </div>
            
            <p>This graph consists of nodes defined as .geojson files in <code>./geojson/</code>. Naming structure of the node is just the node name (e.g. <code>NorthFarm.geojson</code>, think of it as a park attraction), and contains a neighbour array with the filenames of all of its neighbour edges (e.g. <code>"neighbours": [ "KeeleWycombe_to_NorthFarm", "NorthFarm_to_NorthPlaza" ]</code>).</p>
            <p> Each edge is defined in the <code>./geojson/paths/</code> folder with the naming structure being <code>A_to_B.geojson</code> (e.g. <code>KeeleWycombe_to_NorthFarm.geojson</code>, think of it as a pathway to connect various attractions). Each edge contains a MultiLineString or LineString with a feature containing the properties:</p>
            <ul className="list-disc pl-6">
                <li><code>length</code> (int): the length of the edge in meters. This is used by Dijkstra’s algorithm as the weight of the path.</li>
                <li><code>degreeLength</code> (int): the length of the edge in decimal degrees (CRS84), autogenerated by QGIS. Do not use this value for weight, as degreeLength proportions are dependent by the latitude and longitude of the coordinate. Use the Python script found in <code>qgis/degToMeter.py</code> to convert it to the <code>degree</code> parameter.</li>
            </ul>
            <p>The combined nodes and edges are called by the function <code>buildGraph()</code> found in <code>./src/context/GraphContext.tsx</code> to build the weighted graph. <i>The visual length of edges in the figure does not reflect their true weights; this is not important, as the program does not use the figure for calculations.</i></p>
            <div className="pt-3 pb-3">
                <img src="/flightpath/buildGraph.svg" alt="Relationship between each node and edge." className="pb-2 w-full max-w-xl h-auto max-h-96 object-cover sm:max-w-full sm:max-h-none" />
                <i><strong>Image:</strong> full weighted bi-directional graph of Downsview Park's attractions.</i>
            </div>

          <p>Within the same file, when a Pathfinder request is called, then it will feed the starting point and graph to function <code>dijkstras()</code>. It will return a DijkstraResult object, with </p>
          <ul className="list-disc pl-6">
            <li><code>Object with distance</code> (int): distance from previous node</li>
            <li><code>Previous</code> (string): the name of the previous node</li>
          </ul>
          <div className="w-full max-w-full overflow-hidden scale-50 origin-left sm:scale-100">
            <SVGFrameViewer svgPaths={dijkstras} />
            <i><strong>Image:</strong> diagram of an example request to <code>dijkstras()</code> from MiniMound to Playground.</i>
            </div>
          <p>This function works like this:</p>
          <ul className="list-disc pl-6">
            <li><strong>1. </strong> Sets all of the node distances to infinity except the starting one to zero</li>
            <li><strong>2. </strong> At the starting node, examine all adjacent nodes. For each, record the edge weight as its tentative distance and note the starting node as the previous node. </li>
            <li><strong>3. </strong> Place all unvisited neighbour nodes into an array and sort them by their tentative distances (TypeScript's <code>sort()</code> function is used by weight.) This will determine which node to examine next. </li>
            <li><strong>4. </strong> For each node examined, if a shorter path is found (i.e., the new calculated distance is lower than the current recorded distance), update the distance and previous node.</li>
            <li><strong>5. </strong> Continue the process, moving to the node with the smallest tentative distance, until all nodes have been visited.</li>
          </ul>
          <p> The Dijkstra function only gives us a running list of distance and its previous node that it connects to, but we don't know the exact path from the start to end. Hencewhy <code>reconstructPath()</code> is required to backtrack. It returns a string array of node IDs representing the shortest path from the start node to the end node. </p>

          <div className="w-full max-w-full overflow-hidden scale-50 origin-left sm:scale-100">
            <SVGFrameViewer svgPaths={reconstruct} />
            <i><strong>Image:</strong> diagram of an example request to <code>reconstructPath()</code> from MiniMound to Playground.</i>
            </div>

          <p>This function works like this: (note again that this function backtracks)</p>
          <ul className="list-disc pl-6">
            <li><strong>1. </strong> Start with an empty array for the path and set the current node to examine as the end node. The distance is already given here and is constant; it will not change.</li>
            <li><strong>2. </strong> While the previous node parameter is not null, add it to the beginning of the path. Go to that node's listed previous node </li>
            <li><strong>3. </strong> Once previous node is null, return the array representing the shortest path from start to end </li>
          </ul>

          
              </div>

              <Footer/>
        
        </div>






      </div>
    </div>
  </div>
    )
  }
  
  export default FlightPath